
// This is the Compiler Version, that can
// be changed according to new versions
$_compiler_version_$ := "G2.9"

// null Value
null := "NULL"


// ID Generator
$_nextID_$ is Ref = 0u
$_autoId_$() Ref {
	$_nextID_$ += 1u
	return $_nextID_$ - 1u
}


// DB Handling
$_handleDBError_$(Ref db, txt message) {
	if getRc@sqlite() != OK@sqlite {
		jErr@std(fmt(message, " -> ", db.errmsg@sqlite()))
	}
}
$_handleDBErrorWithMessage_$(Ref db, txt message) {
	if getRc@sqlite() != OK@sqlite {
		jErr@std(message)
	}
}
$_localDatabase_$ is Ref = nil
$_getTableName_$(txt index) txt {
	name := ""
	character := 0u
	for i = 0u; i < index.Length () && (character != #"("); i += 1u {
		character = index.CharAt (i)
		if character != #"("
			name = name.InsertChar (character)
	}
	return name
}
$_getTableDescription_$(txt index) txt {
	values := "(id TEXT NOT NULL,"

	primary_keys is txt["id"]
	
	for index.Length () {
		character := index.CharAt (0u)
		index = index.Remove(0u)
		if character == #"(" break
	}

	
	index = index.Remove(index.Length() - 1u)

	if #index == nil return values + "PRIMARY KEY(" + makeString@std(primary_keys, ",") + "))"
	
	fields is split@std(index, ",")
	for i = 0u; i < fields.Size (); i += 1u {
		field is split@std(fields[i], ":")
		identifier := field[0u]
		dbType := field[1u]
		dbType = dbType.upper@std()
		if dbType.cmp@std("UINT") dbType = "INT"

		// In case the variable is in uppercase, it means, it's an primary key
		if isUpper@std(identifier.CharAt(0u))
			values += fmt(identifier, " ", dbType, " NOT NULL,")	
		else
			values += fmt(identifier, " ", dbType, ",")		
	}
	
	return values + "PRIMARY KEY(" + makeString@std(primary_keys, ",") + "))"
}

// New Versions of Table Class shall be
// using a new constructor function
// which is accually allocates space in Memory
// for a Class

// Table Classes
$_constructor_$(*) txt {
	args is $$args$$()
	argt is $$argt$$()
	
	tableIndex := args[0u] as txt
	
	// Init the local Database
	if $_localDatabase_$ == nil {
		$_localDatabase_$ = autoclose_openDB@sqlite(":memory:")
		if getRc@sqlite() != OK@sqlite {
			jErr@std(fmt(
				"Error at initalizing Database: ",
				$_localDatabase_$.errmsg@sqlite()
			))
		}
	}
	
	// Next we'll try to create the table
	tableName := tableIndex.$_getTableName_$()

	// get all values
	tableEntryId := $_autoId_$()
	tableValues := fmt(SQLStringRepresentation@std(fmt(tableIndex, "#", tableEntryId)), ",")
	for i = 1u; i < args.Size (); i += 1u {
		formatType := getFormatType@std(argt[i])
		if formatType == type_ulong@std tableValues += fmt(args[i] as ulong, ",")
		else if formatType == type_long@std tableValues += fmt(args[i] as long, ",")
		else if formatType == type_double@std tableValues += fmt(args[i] as double, ",")
		else if formatType == type_text@std tableValues += fmt(SQLStringRepresentation@std(args[i] as txt), ",")
		else if formatType == type_complex@std tableValues += fmt(SQLStringRepresentation@std(args[i] as txt), ",")
	}
	
	tableValues = tableValues.Remove(tableValues.Length () - 1u)

	sql := fmt(
		"CREATE TABLE IF NOT EXISTS ", tableName, tableIndex.$_getTableDescription_$(), ";",
		"INSERT INTO ", tableName, " VALUES(", tableValues, ");"
	)

	err_msg := $_localDatabase_$.exec@sqlite(sql)

	$_localDatabase_$.$_handleDBErrorWithMessage_$(fmt(
		"Error by initalizing object: ",
		tableName,
		" -> ",
		err_msg
	))

	return fmt(tableIndex, "#", tableEntryId)
}

$_selectText_$(txt tableIndex, txt column) txt {
	tableName := tableIndex.$_getTableName_$()

	sql := fmt(
		"SELECT ", column, " FROM ", tableName, " WHERE id = ", SQLStringRepresentation@std(tableIndex), " LIMIT 1;"
	)
	
	res := $_localDatabase_$.prepare_v2@sqlite(sql, -1)
	$_localDatabase_$.$_handleDBError_$("Error at selecting Text: " + tableName)
	
	
	if step@sqlite(res) == ROW@sqlite {
		field := res.column_text@sqlite(0)
		res.finalize@sqlite()
		return field
	}

	jErr@std("Couldn't find column: " + column + " in tableclass " + tableName)
}

$_selectInt_$(txt tableIndex, txt column) long {
	tableName := tableIndex.$_getTableName_$()

	sql := fmt(
		"SELECT ", column, " FROM ", tableName, " WHERE id = ", SQLStringRepresentation@std(tableIndex), " LIMIT 1;"
	)
	
	res := $_localDatabase_$.prepare_v2@sqlite(sql, -1)
	$_localDatabase_$.$_handleDBError_$("Error at selecting Int: " + tableName)
	
	
	if step@sqlite(res) == ROW@sqlite {
		field := res.column_int@sqlite(0)
		res.finalize@sqlite()
		return field
	}

	jErr@std("Couldn't find column: " + column + " in tableclass " + tableName)
}

$_selectUInt_$(txt tableIndex, txt column) ulong {
	tableName := tableIndex.$_getTableName_$()

	sql := fmt(
		"SELECT ", column, " FROM ", tableName, " WHERE id = ", SQLStringRepresentation@std(tableIndex), " LIMIT 1;"
	)
	
	res := $_localDatabase_$.prepare_v2@sqlite(sql, -1)
	$_localDatabase_$.$_handleDBError_$("Error at selecting uint: " + tableName)
	
	
	if step@sqlite(res) == ROW@sqlite {
		field := res.column_int@sqlite(0)
		res.finalize@sqlite()
		return field
	}

	jErr@std("Couldn't find column: " + column + " in tableclass " + tableName)
}

$_selectFloat_$(txt tableIndex, txt column) double {
	tableName := tableIndex.$_getTableName_$()

	sql := fmt(
		"SELECT ", column, " FROM ", tableName, " WHERE id = ", SQLStringRepresentation@std(tableIndex), " LIMIT 1;"
	)
	
	res := $_localDatabase_$.prepare_v2@sqlite(sql, -1)
	$_localDatabase_$.$_handleDBError_$("Error at selecting float: " + tableName)
	
	
	if step@sqlite(res) == ROW@sqlite {
		field := res.column_double@sqlite(0)
		res.finalize@sqlite()
		return field
	}

	jErr@std("Couldn't find column: " + column + " in tableclass " + tableName)
}

$_update_$(*) {
	args is $$args$$()
	argt is $$argt$$()
	tableIndex := args[0u] as txt
	column     := args[1u] as txt
	
	tableName := tableIndex.$_getTableName_$()
	value := ""
	
	formatType := getFormatType@std(argt[2u])
	if formatType == type_ulong@std        value = fmt(args[2u] as ulong)
	else if formatType == type_long@std    value = fmt(args[2u] as long)
	else if formatType == type_double@std  value = fmt(args[2u] as double)
	else if formatType == type_text@std    value = fmt(SQLStringRepresentation@std(args[2u] as txt))
	else if formatType == type_complex@std value = fmt(SQLStringRepresentation@std(args[2u] as txt))
	
	sql := fmt(
		"UPDATE ", tableName, " SET ", column, " = ", value, " WHERE id = ", SQLStringRepresentation@std(tableIndex), ";"
	)
	
	err_msg := $_localDatabase_$.exec@sqlite(sql)
	$_localDatabase_$.$_handleDBErrorWithMessage_$(err_msg)
}

drop(txt tableIndex) {
	tableName := tableIndex.$_getTableName_$()

	sql := fmt(
		"DELETE FROM ", tableName, " WHERE id = ", SQLStringRepresentation@std(tableIndex), ";"
	)
	
	err_msg := $_localDatabase_$.exec@sqlite(sql)
	$_localDatabase_$.$_handleDBErrorWithMessage_$(err_msg)
}

selectSingle(txt $$tmp_tableName$$, txt $$tmp_condition$$) txt {
	$$tmp_sql$$ = fmt(
		"SELECT id FROM ", $$tmp_tableName$$, " WHERE ", $$tmp_condition$$, " LIMIT 1;"
	)
	
	$$tmp_res$$ := $_localDatabase_$.prepare_v2@sqlite($$tmp_sql$$, -1)

	for $$tmp_res$$.step@sqlite() == ROW@sqlite {
		return $$tmp_res$$.column_text@sqlite(0u)
	}
	
	return null
}

selectById(txt[] $$tmp_elements$$, txt $$tmp_tableName$$, txt $$tmp_column$$, txt $$tmp_target$$, txt $$tmp_id$$) {
	$$tmp_sql$$ = fmt(
		"SELECT ", $$tmp_column$$ ," FROM ", $$tmp_tableName$$ ," WHERE ", $$tmp_target$$ ," = ",
			SQLStringRepresentation@std($$tmp_id$$),
		";"
	)
	
	$$tmp_res$$ := $_localDatabase_$.prepare_v2@sqlite($$tmp_sql$$, -1)

	for $$tmp_res$$.step@sqlite() == ROW@sqlite {
		$$tmp_elements$$.Add($$tmp_res$$.column_text@sqlite(0u))
	}
}

selectAllById(txt[] $$tmp_elements$$, txt $$tmp_tableName$$) {
	$$tmp_sql$$ = fmt(
		"SELECT id FROM ", $$tmp_tableName$$, ";"
	)
	
	$$tmp_res$$ := $_localDatabase_$.prepare_v2@sqlite($$tmp_sql$$, -1)

	for $$tmp_res$$.step@sqlite() == ROW@sqlite {
		$$tmp_elements$$.Add($$tmp_res$$.column_text@sqlite(0u))
	}
}

isNull(txt id) bool = id.cmp@std(null) 

// End Table Classes

